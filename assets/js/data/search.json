[ { "title": "2020 Mock FRQ", "url": "/CSA-Data-Structures/posts/frq20/", "categories": "", "tags": "collegeboard", "date": "2022-04-28 00:00:00 +0000", "snippet": "CodeQuestion 1:Question 2:" }, { "title": "2020 Mock MCQ Corrections", "url": "/CSA-Data-Structures/posts/mcq20/", "categories": "", "tags": "collegeboard", "date": "2022-04-26 00:00:00 +0000", "snippet": "ResultCorrections:Question 9.set and .add is specified with (index, value), not (value, index) as I orignally assumed.Correct Answer: BQuestion 12!borrower.equals(null) would not work because if borrower was null to begin with, than calling .equals would result in a null pointer error.Correct Answer: BQuestion 17Did not account for the initial power level passed to the constructor, which should have been added to the amount specified in the method call.Correct Answer: DQuestion 19x is equal to the sum of all elements in the matrix, with the first number of every row being doubled. Therefore x = 2 + 2 + 3 + 8 + 5 + 6 = 26Correct Answer: DQuestion 28Iteration 1:` a = “si” + “ the song” x = 9`Iteration 2:` a = “si the so” + “” b = -1`Returned: &quot;si the so&quot;Correct Answer: BQuestion 31int counter = 0; for (int i : nums) { if (nums[i] &amp;lt; 0) { counter++; } }Above code is incorrect because it attempts to use values as index.Correct Answer: AQuestion 32An instance of ClassB is being created and stored into a variable of type ClassA, thus when called it is an instance of ClassB being called. Thus the output is B.Correct Answer: BQuestion 33Loop is iterating through columns first, then rows. This means elements are being printed out per column, not per row.Correct Answer: EQuestion 34Size of ArrayList is being reevaulated every loop, therefore out of bounds will never occur. But when removing elements, we are still incrementing i, meaning elements will be skipped due to the next element taking the current index when the current element is removed.Correct Answer: EQuestion 36Options A-C are all false, since when a is smaller than b, methodTwo will always run at least once whereas methodOne will not. Therefore, a%b == 0 guarantees that a &amp;gt; b, and being divisible ensures both method have same behavior.Correct Answer: DQuestion 37num2 &amp;lt; num3 means that num2 will never equal num3, therefore the range is from num2 to num3 exclusive at the end.Correct Answer: EQuestion 38Both I and II are valid choices for iterating through an ArrayList and calling methods on the object.Correct Answer: DQuestion 39Method will only ever return true when each letter in the string is alphabetically larger than the next.Correct Answer: DQuestion 40Even though both variables store an instance of object B, removing message from A will result in variables of type A to not have a method with a signature of message, therefore line 3 will fail.Correct Answer: A" }, { "title": "2015 Mock FRQ", "url": "/CSA-Data-Structures/posts/frq15/", "categories": "", "tags": "collegeboard", "date": "2022-04-21 00:00:00 +0000", "snippet": "CodeQuestion 1:Question 2:Question 3:" }, { "title": "2015 Mock MCQ Corrections", "url": "/CSA-Data-Structures/posts/mcq15/", "categories": "", "tags": "collegeboard", "date": "2022-04-20 00:00:00 +0000", "snippet": "ResultCorrections:Question 27Sort is a selection sort, meaning at each iteration the smallest element will be moved to front of the current unsorted subarray by swapping with whatever element is currently at the beginning of the unsorted subarray.Therefore, the array should progress like this during first three iterations: {1, 3, 2, 5, 4, 6} {1, 2, 3, 5, 4, 6} {1, 2, 3, 5, 4, 6}Correct Answer: BQuestion 28For comparisons, it is located inside a nested for loop, and counting the iterations the nested for loop will iterate 15 times (5 + 4 + 3 + 2 + 1).For swaps, it is located inside the outer for loop, and the outer for loop itereates 6-1 = 5 times.Correct Answer: BQuestion 37II and III will work.II simply starts at the back of the array and adds to the result until startIndex is reached.III reverses the array and iterates size-startIndex-1 number of times whilst adding to result.Correct Answer: EQuestion 38Function recursively iterates through the array looking for v in nums, incrementing when it is found. Therefore it is trying to find number of elements equal to val.Correct Answer: CQuestion 39Setting an element in an ArrayList returns current element there, therefore code is first printing out everything in ArrayList and then printing out ArrayList after modification.Correct Answer: C" }, { "title": "AP Exam Personal Study Guide", "url": "/CSA-Data-Structures/posts/studyguide/", "categories": "", "tags": "collegeboard", "date": "2022-04-18 00:00:00 +0000", "snippet": "My Personal Study Guide for the AP CSA ExamRed Topics (Topics Needing Immediate Review): Dynamic Binding Vehicle v = new Car();, is an example of Dynamic Binding which will use Car’s methods unless overriden. Inheritance (Super Classes) class Child extends Parent, child classes will inherit all of parent’s methods. Insertion, Bubble, Merge, Selection Sort De Morgan’s Law Static, Final, etc. (Important Keywords) static indicates a variable/method that will remain the same regardless of instance of class (Object). final indicates a method/variable that cannot be overriden in a class. Pass By Reference/Value Polymorphism Random Values in a Range Inclusive at the end: Min + (int)(Math.random() * ((Max - Min) + 1)) Exclusive at the end: Min + (Math.random() * (Max - Min)) Yellow Topics (Topics Needing Minimal Review): String Manipulation Arrays/2D Array Methods Iteration (Enhanced For Loops)" }, { "title": "AP Exam Study Plan", "url": "/CSA-Data-Structures/posts/study/", "categories": "", "tags": "collegeboard", "date": "2022-04-18 00:00:00 +0000", "snippet": "OverviewThe following will be my weekly study plan for the upcoming AP Computer Science A Exam. This will be updated weekly to reflect that week’s plan, all the way up until the exam itself in May.Week 1 - 04/18 Monday: Absent. Tuesday: Take 2015 MC during class, review questions I was confused on afterwards. Wednesday: Correct 2015 MC fully, reviewing all missed questions and noting down topics I am weak on. Thursday: Take 2015 FRQ during class, begin reviewing the list of topics I feel I am weak on. Friday: Correct 2015 FRQ fully, and note down areas in which I need improvement, adding onto list of weak topics. Week 2 - 04/25 Monday: Create study plan for the week, establish plan of action. Tuesday: Take 2020 MC during class, review wrong answers afterwards. Wednesday: Correct 2015 MC fully, uploading corrections and descriptions onto Github Pages. Thursday: Take 2020 FRQ during class, and add to list of weak topics. Friday: Correct 2020 FRQ during class, and continue reviewing list of weak topics. Finalize studying for AP Exam next week. " }, { "title": "Tech Talk 3 Notes &amp; Code", "url": "/CSA-Data-Structures/posts/tt3/", "categories": "", "tags": "techtalks", "date": "2022-03-28 00:00:00 +0000", "snippet": "Bubble SortBubble sort moves through a list of elements, checking whether an element is larger than the next, if so swap the two. This will cause large elements to bubble to the back, and small elements slowly move to the front. Eventually, after this process is done enough time the list will be sorted.Statistics:Average Bubble Sort Time: 173.4375msAverage Bubble Sort Comparisons: 1.24975E7Average Bubble Sort Swaps: 6236010.6875Big-O Complexity: O(N^2)Code:public static &amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt; Tuple&amp;lt;Integer, Integer&amp;gt; bubbleSort(ArrayList&amp;lt;T&amp;gt; list) { int comparisons = 0; int swaps = 0; for (int i = 0; i &amp;lt; list.size() - 1; i++) { for (int j = 0; j &amp;lt; list.size() - 1 - i; j++) { if (list.get(j).compareTo(list.get(j + 1)) &amp;gt; 0) { T temp = list.get(j); list.set(j, list.get(j + 1)); list.set(j + 1, temp); swaps++; } comparisons++; } } return new Tuple&amp;lt;&amp;gt;(comparisons, swaps);}Selection Sort:Selection sort splits a list into a subarray which is sorted, and another which is not. It begins with the entire array being unsorted, and moves the smallest element to the front. Now the first element belongs to the subarray which is sorted, and we remove it from the unsorted subarray and repeat. Once we’ve moved through the whole array the list will be sorted.Statistics:Average Selection Sort Time: 45.3125msAverage Selection Sort Comparisons: 1.24975E7Average Selection Sort Swaps: 4999.0Big-O Complexity: O(N^2)Code:public static &amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt; Tuple&amp;lt;Integer, Integer&amp;gt; selectionSort(ArrayList&amp;lt;T&amp;gt; list) { int comparisons = 0; int swaps = 0; for (int i = 0; i &amp;lt; list.size() - 1; i++) { int min = i; for (int j = i + 1; j &amp;lt; list.size(); j++) { if (list.get(j).compareTo(list.get(min)) &amp;lt; 0) { min = j; } comparisons++; } T temp = list.get(i); list.set(i, list.get(min)); list.set(min, temp); swaps++; } return new Tuple&amp;lt;&amp;gt;(comparisons, swaps);}Insertion Sort:Insertion sort takes an element, and compares it with every element before it until it finds the position at which it is smaller than the next element but larger than the previous element and inserts it there. This is done for every element in the list, and at the end the list will be sorted.Statistics:Average Insertion Sort Time: 48.9375msAverage Insertion Sort Comparisons: 6247429.1875Average Insertion Sort Swaps: 6252428.1875Big-O Complexity: O(N^2)Code:public static &amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt; Tuple&amp;lt;Integer, Integer&amp;gt; insertionSort(ArrayList&amp;lt;T&amp;gt; list) { int comparisons = 0; int swaps = 0; for (int i = 1; i &amp;lt; list.size(); i++) { T temp = list.get(i); int j = i; while (j &amp;gt; 0 &amp;amp;&amp;amp; temp.compareTo(list.get(j - 1)) &amp;lt; 0) { list.set(j, list.get(j - 1)); j--; comparisons++; swaps++; } list.set(j, temp); swaps++; } return new Tuple&amp;lt;&amp;gt;(comparisons, swaps);}Merge Sort:Merge sort takes a divide and conquer strategy, splitting a list into half repeatedly until a list has been split into the smallest pieces possible. Then we proceed to recursively merge these subarrays into an order array, by using a two pointer method where we compare the top of two subarrays and add which ever element is smaller, and increment that subarray. At the end of the recursive tree, we now have a merged sorted list.Statistics:Average Merge Sort Time: 50.5625msAverage Merge Sort Comparisons: 5000.0Average Merge Sort Swaps: 5000.0Big-O Complexity: O(N log(N))Code:public static &amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt; Tuple&amp;lt;Integer, Integer&amp;gt; mergeSort(ArrayList&amp;lt;T&amp;gt; list) { int comparisons = 0; int swaps = 0; if (list.size() &amp;gt; 1) { ArrayList&amp;lt;T&amp;gt; left = new ArrayList&amp;lt;T&amp;gt;(); ArrayList&amp;lt;T&amp;gt; right = new ArrayList&amp;lt;T&amp;gt;(); for (int i = 0; i &amp;lt; list.size() / 2; i++) { left.add(list.get(i)); } for (int i = list.size() / 2; i &amp;lt; list.size(); i++) { right.add(list.get(i)); } mergeSort(left); mergeSort(right); Tuple&amp;lt;Integer, Integer&amp;gt; stats = merge(left, right, list); comparisons += stats.x; swaps += stats.y; } return new Tuple&amp;lt;&amp;gt;(comparisons, swaps);}private static &amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt; Tuple&amp;lt;Integer, Integer&amp;gt; merge(ArrayList&amp;lt;T&amp;gt; left, ArrayList&amp;lt;T&amp;gt; right, ArrayList&amp;lt;T&amp;gt; list) { int i = 0, j = 0, k = 0; int comparisons = 0; int swaps = 0; while (i &amp;lt; left.size() &amp;amp;&amp;amp; j &amp;lt; right.size()) { if (left.get(i).compareTo(right.get(j)) &amp;lt; 0) { list.set(k, left.get(i)); i++; swaps++; } else { list.set(k, right.get(j)); j++; swaps++; } comparisons++; k++; } while (i &amp;lt; left.size()) { list.set(k, left.get(i)); i++; k++; comparisons++; swaps++; } while (j &amp;lt; right.size()) { list.set(k, right.get(j)); j++; k++; comparisons++; swaps++; } return new Tuple&amp;lt;&amp;gt;(comparisons, swaps);}Conclusion:After examining all 4 methods of sorting, Merge Sort is the best because it has the smallest Big-O Time Complexity, a 3-way tie in terms of average time, and the smallest amount of swaps and comparisons." }, { "title": "PBL Presentation Feedback Notes", "url": "/CSA-Data-Structures/posts/pbl/", "categories": "", "tags": "feedback", "date": "2022-03-25 00:00:00 +0000", "snippet": "Notable Feedback Frontend needs more work, navigation and page organization/worflow. Need some kind of frontend tool to display data, what tool/library? Project can be expanded beyond just the scopes of neuroscience.Plan of Action Frontend planning needed, Figma will be our choice of wireframing. Figma wireframe mockup for Navbar Figma wireframe mockup for Homepage Figma wireframe mockup for Data Upload Page Figma wireframe mockup for Data Analysis Page Frontend workflow/navigation flow needs work, currently unclear how everything is linked, will investigate. Plan out backend infrastructure, aws, s3 buckets, pricing/payment? Find good tool for displaying CSV graphics on frontend, charts.js?" }, { "title": "Tech Talk 2 Notes &amp; Code", "url": "/CSA-Data-Structures/posts/tt2/", "categories": "", "tags": "techtalks", "date": "2022-03-24 00:00:00 +0000", "snippet": "Reverse Polish Notation In mathematics, an expression or mathematical expression is a finite combination of symbols that is well-formed according to rules that depend on the context. In computers, expression can be hard to calculate with precedence rules. In computer math we often convert strings into Reverse Polish Notation (RPN, 3 + 4 becomes 3 4 +) using the Shunting-yard algorithm. RPN involves using a Stack, which aligns with CSA Tri-3’s content as well as CollegeBoard’s material.Replit Runtime + Github Repo: Code PageChallenge - Implement Reverse Polish Notationprivate void tokensToReversePolishNotation() { this.reverse_polish = new ArrayList&amp;lt;&amp;gt;(); Stack&amp;lt;String&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); for (String token : this.tokens) { if (isOperator(token) || isFunction(token)) { while (!stack.empty() &amp;amp;&amp;amp; (isOperator(stack.peek()) || isFunction(stack.peek()))) { if (isPrecedent(token, stack.peek())) { reverse_polish.add(stack.pop()); } else { break; } } stack.push(token); } else if (isSeperator(token)) { if (token.equals(&quot;(&quot;)) { stack.push(token); } else if (token.equals(&quot;)&quot;)) { while (!stack.empty() &amp;amp;&amp;amp; !stack.peek().equals(&quot;(&quot;)) { reverse_polish.add(stack.pop()); } stack.pop(); } } else { reverse_polish.add(token); } } while (!stack.empty()) { reverse_polish.add(stack.pop()); }}private void rpnToResult() { Stack&amp;lt;Double&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); for (String token : reverse_polish) { if (isOperator(token)) { Double operand2 = stack.pop(); Double operand1 = stack.pop(); Double result = 0.0; switch (token) { case &quot;+&quot;: result = operand1 + operand2; break; case &quot;-&quot;: result = operand1 - operand2; break; case &quot;*&quot;: result = operand1 * operand2; break; case &quot;/&quot;: result = operand1 / operand2; break; case &quot;%&quot;: result = operand1 % operand2; break; case &quot;^&quot;: result = Math.pow(operand1, operand2); break; } stack.push(result); } else if (isFunction(token)) { Double operand = stack.pop(); Double result = 0.0; switch (token) { case &quot;SQRT&quot;: result = Math.sqrt(operand); break; } stack.push(result); } else { stack.push(Double.parseDouble(token)); } } this.result = stack.pop();}" }, { "title": "Tech Talk 1 Notes &amp; Code", "url": "/CSA-Data-Structures/posts/tt1/", "categories": "", "tags": "techtalks", "date": "2022-03-18 00:00:00 +0000", "snippet": "Linked Lists Linked Lists is just a list of nodes connected to each other with pointers. Each node has a head and tail which points to the previous and next node. Linked Lists can be used to create Queues and Stacks.Replit Runtime + Github Repo: Code PageChallenge 1 - Add/Delete from Queuepublic void add(T data) { LinkedList&amp;lt;T&amp;gt; tail = new LinkedList&amp;lt;&amp;gt;(data, null); if (head == null) this.head = this.tail = tail; else { this.tail.setNextNode(tail); this.tail = tail; } size++; System.out.println(&quot;Enqueued data: &quot; + data); System.out.print(&quot;Words count: &quot; + this.size + &quot;, data: &quot;); for (T t : this) { System.out.print(t + &quot; &quot;); } System.out.println();}public void delete() { if (head == null) { System.out.println(&quot;Queue is empty&quot;); return; } System.out.println(&quot;Dequeued data: &quot; + head.getData()); head = head.getNext(); size--; System.out.print(&quot;Words count: &quot; + this.size + &quot;, data: &quot;); for (T t : this) { System.out.print(t + &quot; &quot;); } System.out.println();}Challenge 2 - Merge QueuesQueue&amp;lt;Integer&amp;gt; sortedQueue = new Queue&amp;lt;&amp;gt;();while (true) { if (q.getHead() != null &amp;amp;&amp;amp; q2.getHead() != null) { int a = q.getHead().getData(); int b = q2.getHead().getData(); if (a &amp;lt; b) { sortedQueue.add(a); q.delete(); } else { sortedQueue.add(b); q2.delete(); } } else { while (q.getHead() != null) { sortedQueue.add(q.getHead().getData()); q.delete(); } while (q2.getHead() != null) { sortedQueue.add(q2.getHead().getData()); q2.delete(); } break; }}System.out.print(&quot;Sorted Queue: &quot;);for (int i : sortedQueue) { System.out.print(i + &quot; &quot;);}System.out.println();Challenge 3 - Stack from Queuepublic class Stack&amp;lt;T&amp;gt;{ private LinkedList&amp;lt;T&amp;gt; lifo; public Stack() { lifo = null; } public Object peek() { if (lifo == null) return null; else return lifo.getData(); } public void push(T value) { lifo = new LinkedList&amp;lt;&amp;gt;(value, lifo); } public Object pop() { Object value = null; if (lifo != null) { value = lifo.getData(); lifo = lifo.getPrevious(); } return value; } public String toString() { StringBuilder stackToString = new StringBuilder(&quot;[&quot;); LinkedList&amp;lt;T&amp;gt; node = lifo; // start from the back while (node != null) { stackToString.append(node.getData()); // append the database to output string node = node.getPrevious(); // go to previous node if (node != null) stackToString.append(&quot;, &quot;); } // loop &#39;till you reach the beginning stackToString.append(&quot;]&quot;); return stackToString.toString(); }}Queue&amp;lt;Integer&amp;gt; q = new Queue&amp;lt;&amp;gt;();q.add(1);q.add(2);q.add(3);Stack&amp;lt;Integer&amp;gt; s = new Stack&amp;lt;&amp;gt;();for (Integer i : q) { s.push(i);}System.out.println(s);" }, { "title": "Tech Talk 0 Notes &amp; Code", "url": "/CSA-Data-Structures/posts/tt0/", "categories": "", "tags": "techtalks", "date": "2022-03-10 00:00:00 +0000", "snippet": "Intro A data structure is a method of organizing data. Think of algorithms as dynamic underlying pieces that interact with data structures. Together, data structures and algorithms combine and allow programmers to build whatever computer programs they’d like.Programming Paradigms Imperative Paradigm A programming paradigm that uses statements that change a program’s state. Consists of a list of commands that describe how the program operates. Object Oriented Paradigm A programming paradigm that relies on the concept of classes and objects. Used to structure a software program into simple, reusable pieces of code blueprints Basic Data Structures: Arrays Linear data structure in which data is stored one after another. Iteration. Hash Maps Non-Linear data structure in which data is associated with a key when stored. Replit Runtime + Github Repo: Code PageChallenge 1 - Menupublic static void menu() { int selection = 0; Scanner scan = new Scanner(System.in); print_menu(); try { selection = scan.nextInt(); clear(); if (selection == 0) { scan.close(); System.exit(0); } else if (prompts.containsKey(selection)) { prompts.get(selection).run(prompts); } else { System.out.println(&quot;Invalid choice.&quot;); } } catch (Exception e) { clear(); System.out.println(&quot;Invalid choice.&quot;); scan.nextLine(); } menu();}Challenge 2 - Int Referencepublic void swapToLowHighOrder() { if (this.value &amp;gt; this.value2) { this.value = this.value - this.value2; this.value2 = this.value + this.value2; this.value = this.value2 - this.value; }}Challenge 3 - Matrixpublic String toString() { StringBuilder sb = new StringBuilder(); for (int i = 0; i &amp;lt; matrix.length; i++) { for (int j = 0; j &amp;lt; matrix[i].length; j++) { if (matrix[i][j] == -1) { sb.append(&quot; &quot;); } else { sb.append(matrix[i][j] + &quot; &quot;); } } sb.append(&quot;\\n&quot;); } sb.append(&quot;\\n&quot;); for (int i = matrix.length - 1; i &amp;gt;= 0; i--) { for (int j = matrix[i].length - 1; j &amp;gt;= 0; j--) { if (matrix[i][j] == -1) { sb.append(&quot; &quot;); } else { sb.append(matrix[i][j] + &quot; &quot;); } } sb.append(&quot;\\n&quot;); } return sb.toString();}" } ]
